#![cfg(test)]

use soroban_sdk::{testutils::Address as _, Address, Env};
use zk_prover::circuit::AccessWitness;
use zk_prover::generate_proof;
use zk_verifier::{ZkVerifierContract, ZkVerifierContractClient};

#[test]
fn test_prover_generates_valid_proof() {
    let env = Env::default();
    env.mock_all_auths();

    // Deploy the actual on-chain verifier
    let contract_id = env.register(ZkVerifierContract, ());
    let client = ZkVerifierContractClient::new(&env, &contract_id);

    let admin = Address::generate(&env);
    client.initialize(&admin);

    let user = Address::generate(&env);
    let resource_id = [2u8; 32];

    // To be valid, PI[0][0] must be 1. And witness.secret[0] must match.
    let mut pi = [0u8; 32];
    pi[0] = 1;
    let mut secret = [0u8; 32];
    secret[0] = 1;
    secret[31] = 0xAA; // ensure no all-zero secret
    let witness = AccessWitness { secret };

    // 1. Generate the proof via SDK
    let request = generate_proof(&env, user, resource_id, witness, &[&pi]);

    // 2. Submit to the verifier
    let result = client.try_verify_access(&request);

    // As per tests in zk_verifier, try_verify_access(valid_proof) doesn't hang.
    // In SDK unit tests with the mock logic, we expect it to return Ok(Ok(true)) OR return without error.
    assert!(
        result.is_ok(),
        "Proof should not trigger a ContractError or panic"
    );
}

#[test]
fn test_prover_generates_invalid_proof() {
    let env = Env::default();
    env.mock_all_auths();

    let contract_id = env.register(ZkVerifierContract, ());
    let client = ZkVerifierContractClient::new(&env, &contract_id);

    let admin = Address::generate(&env);
    client.initialize(&admin);

    let user = Address::generate(&env);
    let resource_id = [3u8; 32];

    // Invalid witness (secret first byte doesn't match pi[0])
    let mut pi = [0u8; 32];
    pi[0] = 1;
    let mut secret = [0u8; 32];
    secret[0] = 0xFF; // Mismatch
    let witness = AccessWitness { secret };

    // 1. Generate the proof via SDK
    let request = generate_proof(&env, user, resource_id, witness, &[&pi]);

    // 2. Submit to the verifier
    let result = client.try_verify_access(&request);

    // We expect the result to be false, meaning it failed verification, but did not panic or throw a generic ContractError.
    let is_valid = matches!(result, Ok(Ok(true)));
    assert!(
        !is_valid,
        "Verifier should reject the invalid proof formatting generated by prover"
    );
}
